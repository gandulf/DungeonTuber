import random

import librosa
import numpy as np
import scipy
from PySide6.QtCore import QTimer
from PySide6.QtGui import QColor, QBrush, QPainter, QLinearGradient
from PySide6.QtWidgets import QWidget


class RealVisualizerWidget(QWidget):
    """
    A custom Qt Widget that renders a simulated spectral analyzer.
    Since getting real-time FFT data from libvlc via Python is technically
    complex and unstable, this visualizer reacts to playback state
    and volume amplitude to simulate activity.
    """

    fakeMode = False

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setMinimumHeight(40)
        self.setContentsMargins(4,4,4,4)
        self.playing = False
        self.sleeping = True
        self.amplitude = 0
        self.bars = 30
        self.values = [0.0] * self.bars
        self.current_hop = 0
        self.char_indices = []

        base_color = QColor(self.palette().base().color())
        base_color.setAlpha(150)
        self.base_fill = QBrush(base_color)

        self.hop_length_secs = 1 / 30
        # Timer for animation loop (60 FPS)
        self.timer = QTimer(self)

        self.timer.timeout.connect(self.update_real_visualization)
        self.timer.start(int(self.hop_length_secs*1000))


    def load_mp3(self, filename):
        # Tunable parameters
        self.current_hop = 0

        y, sr = librosa.load(filename, sr=22050)

        sound_length = y.shape[0] / sr
        #print(f"{sound_length = }")
        hop_length_samples = int(self.hop_length_secs * sr)
        #print(f"{self.hop_length_secs = }")
        #print(f"{hop_length_samples = }")

        stft = np.abs(librosa.stft(y, n_fft=1024, hop_length=hop_length_samples))
        num_bins, num_samples = stft.shape

        # This should be approximately `sound_length` now
        #print(f"{num_samples * self.hop_length_secs = }")

        # Resample to the desired number of frequency bins
        stft2 = np.abs(scipy.signal.resample(stft, self.bars, axis=0))
        stft2 = stft2 / np.max(stft2)  # Normalize to 0..1

        # Remap the 0..1 signal to integer indices
        # -- the square root boosts the otherwise lower signals for better visibility.
        self.char_indices = np.sqrt(stft2)

    def set_position(self, position_0_1000):
        if len(self.char_indices)>0:
            hobs = len(self.char_indices[0])
            self.current_hop = min(hobs - 1, int(hobs * (position_0_1000 / 1000.0)))
        else:
            self.current_hop = 0

    def set_state(self, is_playing, volume):
        self.playing = is_playing
        self.amplitude = volume / 100.0

    def update_real_visualization(self):
        if self.playing:
            if self.current_hop < len(self.char_indices[0]) - 1:
                self.current_hop += 1

            for i in range(self.bars):
                self.values[i] = self.char_indices[i, self.current_hop] * self.amplitude
        else:
            # Decay to zero
            for i in range(self.bars):
                self.values[i] *= 0.85

        self.update()



    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)

        w = self.width() - self.contentsMargins().left() - self.contentsMargins().right()
        h = self.height() - self.contentsMargins().top() - self.contentsMargins().bottom()

        painter.fillRect(self.rect(), self.base_fill)

        bar_width = w / self.bars

        # Gradient brush for a modern look
        gradient = QLinearGradient(0, h, 0, 0)
        gradient.setColorAt(0.0, _green)  # Green
        gradient.setColorAt(0.4, _yellow)  # yellow
        gradient.setColorAt(0.6, _orange)  # Orange
        gradient.setColorAt(1.0, _red)  # Red

        for i, val in enumerate(self.values):
            bar_h = max(1, int(val * h * 1.2)) # make the bars fill up more space by using factor 1.2
            x = self.contentsMargins().left() + i * bar_width
            y = self.contentsMargins().top() + h - bar_h

            painter.fillRect(int(x), int(y), int(bar_width - 2), int(bar_h), gradient)
